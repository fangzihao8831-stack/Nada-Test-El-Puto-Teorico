#!/usr/bin/env node

/**
 * Reads question JSON files from content/preguntas/batch_*
 * and generates src/lib/question-bank.ts with BankQuestion entries.
 * Also copies referenced signal SVGs to public/images/senales/.
 *
 * Usage: node scripts/generate-question-bank.mjs
 */

import { readFileSync, writeFileSync, readdirSync, existsSync, statSync, mkdirSync, copyFileSync } from "node:fs";
import { join, resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const appRoot = resolve(__dirname, "..");
const projectRoot = resolve(appRoot, "..");

// Read content-structure.json for subtema -> tema mapping
const structurePath = join(projectRoot, "content", "content-structure.json");
const structure = JSON.parse(readFileSync(structurePath, "utf-8"));

const subtemaToTema = {};
const temaNames = {};
for (const tema of structure.temas) {
  temaNames[tema.id] = tema.nombre;
  for (const subtema of tema.subtemas) {
    subtemaToTema[subtema.id] = tema.id;
  }
}

// Load signal catalog for codigo_señal -> SVG path resolution
const catalogoPath = join(projectRoot, "content", "imagenes", "senales", "catalogo.json");
const senalMap = {};
if (existsSync(catalogoPath)) {
  const catalogo = JSON.parse(readFileSync(catalogoPath, "utf-8"));
  for (const s of catalogo) {
    senalMap[s.codigo] = s.archivo;
  }
}

// Collect all question JSON files from batch directories
const preguntasDir = join(projectRoot, "content", "preguntas");

if (!existsSync(preguntasDir)) {
  console.error("No content/preguntas directory found");
  process.exit(1);
}

const entries = readdirSync(preguntasDir);
const batchDirs = entries
  .filter((d) => {
    const fullPath = join(preguntasDir, d);
    return d.startsWith("batch_") && statSync(fullPath).isDirectory();
  })
  .sort();

const allQuestions = [];
const referencedSvgs = new Set();

for (const batch of batchDirs) {
  const batchPath = join(preguntasDir, batch);
  const allFiles = readdirSync(batchPath).filter((f) => f.endsWith(".json"));

  // For each original file, prefer its _validated version if it exists
  const originals = allFiles.filter((f) => !f.includes("_validated"));
  const files = originals.map((f) => {
    const validated = f.replace(".json", "_validated.json");
    return allFiles.includes(validated) ? validated : f;
  });

  for (const file of files) {
    const filePath = join(batchPath, file);
    const data = JSON.parse(readFileSync(filePath, "utf-8"));
    if (!data.preguntas || !Array.isArray(data.preguntas)) continue;

    for (const q of data.preguntas) {
      const temaId = subtemaToTema[q.subtema_id] || "unknown";
      const temaName = temaNames[temaId] || "Desconocido";

      // Resolve signal image: check both "codigo_señal" and "codigo_senal" keys
      const codigoSenal = q["codigo_señal"] || q.codigo_senal || null;
      const svgPath = codigoSenal && senalMap[codigoSenal]
        ? `/images/senales/${senalMap[codigoSenal]}`
        : null;

      if (svgPath && codigoSenal) {
        referencedSvgs.add(senalMap[codigoSenal]);
      }

      const question = {
        id: q.id,
        number: 0,
        enunciado: q.enunciado,
        opciones: q.opciones.map((opt, i) => ({
          key: String.fromCharCode(65 + i),
          texto: opt,
        })),
        correcta: String.fromCharCode(65 + q.correcta),
        explicacion: q["explicación"] || q.explicacion || "",
        hasImage: q.requiere_imagen !== false,
        imageSrc: svgPath,
        temaId,
        tema: temaName,
      };

      if (q.pista) question.pista = q.pista;
      if (q.tipo_pregunta) question.tipoPregunta = q.tipo_pregunta;

      allQuestions.push(question);
    }
  }
}

// Sort by tema for readability
allQuestions.sort((a, b) => a.temaId.localeCompare(b.temaId));

// Copy referenced signal SVGs to public/images/senales/
const senalesSourceDir = join(projectRoot, "content", "imagenes", "senales");
const senalesDestDir = join(appRoot, "public", "images", "senales");

if (referencedSvgs.size > 0) {
  for (const svgRelPath of referencedSvgs) {
    const srcPath = join(senalesSourceDir, svgRelPath);
    const destPath = join(senalesDestDir, svgRelPath);
    const destDir = dirname(destPath);

    if (!existsSync(destDir)) {
      mkdirSync(destDir, { recursive: true });
    }

    if (existsSync(srcPath)) {
      copyFileSync(srcPath, destPath);
    } else {
      console.warn(`  Warning: SVG not found for ${svgRelPath}`);
    }
  }
  console.log(`Copied ${referencedSvgs.size} signal SVGs to public/images/senales/`);
}

// Generate TypeScript
const questionsJson = JSON.stringify(allQuestions, null, 2);

const ts = `import type { TestQuestion } from "./mock-test-data";

/**
 * Validated DGT questions from the content pipeline.
 * Auto-generated by scripts/generate-question-bank.mjs — do not edit manually.
 */

export interface BankQuestion extends TestQuestion {
  temaId: string;
}

export const questionBank: BankQuestion[] = ${questionsJson};
`;

const outPath = join(appRoot, "src", "lib", "question-bank.ts");
writeFileSync(outPath, ts);

// Summary
const byTema = {};
let withImage = 0;
for (const q of allQuestions) {
  byTema[q.temaId] = (byTema[q.temaId] || 0) + 1;
  if (q.imageSrc) withImage++;
}

console.log(`Generated ${allQuestions.length} questions from ${batchDirs.length} batches`);
console.log(`  ${withImage} with signal image, ${allQuestions.length - withImage} without`);
console.log("Distribution by tema:");
for (const [tema, count] of Object.entries(byTema).sort()) {
  console.log(`  ${tema}: ${count}`);
}
